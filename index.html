<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Hexagones avec contrôle pitch/bearing et filtres</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@4.0.0/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/deck.gl@9.0.33/dist.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>


<style>
html, body {
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  overflow-x:hidden;
}

/* Conteneur global */
#App {
  display: flex;
  flex-direction: column;
  min-height: 100vh; /* pour que le body scroll si nécessaire */
}

/* Conteneur map + contrôles */
#appContainer {
  height: 100vh;
  flex: 1 0 auto;       /* prend tout l’espace disponible */
  display: flex;
  flex-direction: column;
  position: relative;
}

/* Conteneur map */
#mapContainer {
  flex: 1 1 auto;       /* prend tout l’espace restant dans appContainer */
  display: flex;
  position: relative;
}

/* Map */
#map {
  flex: 1 1 auto;
}

/* Page title */
#pageTitle {
  flex-shrink: 0;
  position: absolute;
  width: 100%;
  text-align: center;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  padding: 6px 12px;
  border-radius: 6px;
  font-family: sans-serif;
  font-size: clamp(22px, 5vw, 32px);
  font-weight: bold;
  color:#4676fccc;
  filter: 
    drop-shadow(-1px -1px 2px rgba(100,100,100,0.3))
    drop-shadow(1px -1px 2px rgba(100,100,100,0.3))
    drop-shadow(-1px 1px 2px rgba(100,100,100,0.3))
    drop-shadow(1px 1px 2px rgba(100,100,100,0.3));
  pointer-events: none;
}

/* Stats calendar */
#statsCalendar{
  height: 500px;
  width: fit-content;
  background:#f0f0f0; /* couleur d’exemple */
}
#statsCalendar svg { font-size: 10px; display: block;}
#calendar-container {
      width: 100%;        /* largeur visible du calendrier */
      height: 300px;       /* hauteur visible du calendrier */
      overflow: auto;      /* scroll automatique si contenu dépasse */
      border: 1px solid #ccc; 
    }


    .day-cell {
      stroke: #ccc;
      stroke-width: 0.5px;
    }

    .month-label { font-weight: bold; }
    .day-label { text-anchor: end; alignment-baseline: middle; }

/* Contrôles */
#controlsContainer { position:absolute; top:58px; left:10px; z-index:1000; }
#controlsHeader {
  width: 20px;
  height: 28px;
  background:rgba(255,255,255,0.8);
  padding:6px 10px;
  border-radius:6px;
  box-shadow:0 2px 6px rgba(0,0,0,0.2);
  font-family:sans-serif;
  cursor:pointer;
  user-select:none;
}
#controlsContent {
  display:none;
  background:rgba(255,255,255,0.8);
  padding:8px;
  border-radius:6px;
  margin-top:4px;
  max-height:80vh;
  overflow-y:auto;
  box-shadow:0 2px 6px rgba(0,0,0,0.2);
}
#controlsContent label { display:block; margin-top:5px; }

/* Toggle layers */
#layerToggle {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 1000;
}
#layerToggle button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.5);
  background: rgba(255,255,255,0.8);
  cursor: pointer;
  padding: 0;
}
#themeButton{
  border-radius: 6px;
  margin: 0;
  border: 1px solid rgba(0,0,0,0.5);
  cursor:pointer;
  width: 40px; 
}
#layerToggle button img,
#layerToggle button svg { width: 24px; height: 24px; }
#layerToggle label { display:block; }

/* Toggle button style */
.toggle-button {
  position: relative;
  width: 35px;
  height: 35px;
  background: rgba(255,255,255,0.8);
  border: 1px solid rgba(0,0,0,0.3);
  border-radius: 6px;
  margin: 2px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s;
}
.toggle-button img { width: 24px; height: 24px; }
.toggle-button:not(.active)::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 70%;
  height: 2px;
  background: red;
  transform: translate(-50%, -50%) rotate(45deg);
}

/* Légende */
.legend {
  position: absolute;
  bottom: 18px;
  left: 10px;
  width: 9rem;
  padding: 0.5rem;
  font-family: sans-serif;
  font-size: 10px;
  z-index: 1000;
  background: rgba(255,255,255,0.8);
  border-radius: 4px;
}
.legendColorBar { width: 100%; height: 0.8rem; display: flex; }
.legendColorBar div { flex: 1; }
#legendValues { position: relative; width: 100%; height: 1rem; margin-bottom: 0.2rem; }
#legendValues span { position: absolute; top: 0; transform: translateX(-50%); }
#minValue { left: 0%; } #midValue { left: 50%; } #maxValue { left: 100%; }

/* Filtre compétences */
#filterContainer {
  position: absolute;
  bottom: 35px;
  right: 10px;
  width: 220px;
  z-index: 1000;
  font-family: sans-serif;
  background: rgba(255,255,255,0.8);
  border-radius: 6px;
  box-shadow:0 2px 6px rgba(0,0,0,0.2);
}
#filterHeader { padding: 6px 10px; cursor: pointer; user-select: none; text-align: end; }
#filterContent { padding: 8px; display: block; max-height: 30rem; overflow-y: auto; }
#filterContent label { display: block; margin: 4px; }
#filterCheckboxes { max-height: 19.5rem; overflow-y: auto; border:1px solid #ccc; padding:4px; border-radius:4px; background:#fff; }
#filterDateRange input { margin-left:auto;margin-right:auto;}

/* Filtre geo */
#filterGeo{
  display:flex;
  flex-direction: column;
  row-gap:6px;
  margin-left: 3px;
  margin-top: 12px;
  padding: 0;
}
#filterGeo input{ width: 40px; border-radius: 3px; }

/* Responsive */
@media (max-width: 600px) {
  #pageTitle {
    position: relative;
    top: auto;
    left: auto;
    transform: none;
    text-align: center;
    width: 100%;
    font-size: 5vw;
    padding: 8px 0;
    margin-bottom: 4px;
    background: rgba(255,255,255,0.8);
  }
  .legend {
    left: 10px;
    right: 10px;
    width: auto;
  }
  #filterContainer { bottom: calc(35px + 40px); }
  .maplibregl-ctrl-bottom-right{ display: none; }
  #controlsContainer{ top:10px; }
}
@media(max-width:375px){
  #layerToggle{ flex-direction:row-reverse; }
}

.input-with-unit {
  display: flex;
  flex-direction: column;
  align-items: center;   /* centre horizontalement */
  font-family: sans-serif;
  background: rgba(255,255,255,0.8);
  border: 1px solid rgba(0,0,0,0.3);
  border-radius: 6px;
}

.input-with-unit input {
  width: 100px;           /* largeur confortable */
  /* padding: 6px 8px; */
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  text-align: center;     /* option : centrer la saisie */
  box-sizing: border-box;
}

.input-with-unit .unit {
  margin-top: 4px;        /* espace entre champ et unité */
  font-size: 12px;
  color: #555;
}



</style>

</head>
<body>
  <div id="App">
    <div id="appContainer">
        <div id="pageTitle">Carte Stacks Dev France</div>
        <div id="mapContainer">
        <div id="map"></div>     

        <!-- Contrôles -->
        <div id="controlsContainer">
            <div id="controlsHeader">
            <img width="100%" height="100%" src="src/icon/Setting.svg" alt="Setting">
            </div>
            <div id="controlsContent">
            <label>Rayon hexagones (m):
                <input type="range" id="radiusSlider" min="500" max="5000" step="50" value="1000">
                <span id="radiusValue">1000</span>
            </label>
            <label>Hauteur 3D (elevationScale):
                <input type="range" id="elevationSlider" min="10" max="100" step="5" value="50">
                <span id="elevationValue">50</span>
            </label>
            <label>Coverage extrudé:
                <input type="range" id="coverageSlider" min="0.1" max="1" step="0.05" value="0.8">
                <span id="coverageValue">0.8</span>
            </label>
            <label>Opacité extrudé:
                <input type="range" id="hexOpacitySlider" min="0.1" max="1" step="0.05" value="0.8">
                <span id="hexOpacityValue">0.8</span>
            </label>
            <label>Coverage base:
                <input type="range" id="baseCoverageSlider" min="0.1" max="1" step="0.05" value="1">
                <span id="baseCoverageValue">1</span>
            </label>
            <label>Opacité base:
                <input type="range" id="baseOpacitySlider" min="0.1" max="1" step="0.05" value="0.5">
                <span id="baseOpacityValue">0.5</span>
            </label>
            <label>Échelle couleur:
                <select id="scaleMode">
                <option value="linear">Linéraire</option>
                <option value="log" selected>Logarithmique</option>
                </select>
            </label>
            <label>Style carte:
                <select id="styleMode">
                <option value="dark" selected>Dark</option>
                <option value="light">Light</option>
                </select>
            </label>
            </div>
        </div>
    

        <!-- Toggle layers -->
        <div id="layerToggle">
            <button id="themeButton" >
            <svg id="themeIcon" width="100%" height="100%" viewBox="0 0 24 24" fill="orange"></svg>
            </button>
            <button id="toggleBase" class="toggle-button active" title="Afficher la base">
            <img width="100%" height="100%" src="src/icon/Base.svg" alt="Base">
            </button>
            <button id="toggleExtrude" class="toggle-button active" title="Afficher la base">
            <img width="100%" height="100%" src="src/icon/Extrude.svg" alt="Base">
            </button>

            <!--Filtre Géo-->
            <div id="filterGeo">
                <button id="active_circle"></button>
                <button id="edit_circle"></button>
                <div class="input-with-unit">
                    <input type="number" id="cRadiusKm" value="50" min="0" step="1">
                    <span class="unit">km</span>
                </div>
                <!-- <input type="number" min="1" id="cRadiusKm" value="20"> -->
            </div>
                
        </div>

        <!-- Légende -->
        <div class="legend" id="legendContainer">
            <div id="legendValues">
            <span id="minValue">0</span>
            <span id="midValue">0</span>
            <span id="maxValue">0</span>
            </div>
            <div class="legendColorBar" id="legendBar"></div>
        </div>

        <!-- Filtre compétences -->
        <div id="filterContainer">
            <div id="filterHeader">Filtres ▾</div>
            <div id="filterContent">
                <label id="filterDateRange">Filtre par date :
                <input type="date" id="minDate">
                <input type="date" id="maxDate">
                </label>
                
                <label>Mode de filtre:
                    <select id="filterMode">
                    <option value="OU">OU</option>
                    <option value="ET">ET</option>
                    </select>
                </label>
                <div id="filterCheckboxes"></div>
            </div>
        </div>
    </div>
    </div>
    <div id="calendar-container">
        <div id="statsCalendar"></div>
    </div>
  </div>




<script type="module">
const {HexagonLayer, MapboxOverlay} = deck;

// --- Map styles ---
const MAP_STYLES = {
  dark: { url:'https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json',
          colors:[[64,64,255],[64,160,255],[255,255,128],[255,180,80],[255,64,64]] },
  light:{ url:'https://tiles.openfreemap.org/styles/bright', 
          colors:[[33,40,230],[151,77,183],[255,204,0],[255,128,0],[204,0,0]] }
};
const paletteColorLen = 50;
let currentStyle='dark', currentScaleMode='log';

// --- svg buton switch mode ---
const LIGHT_ICON_PATH  =  '<path fill="#fff700" d="M12 16q-1.671 0-2.835-1.164Q8 13.67 8 12t1.165-2.835T12 8t2.836 1.165T16 12t-1.164 2.836T12 16m-7-3.5H1.5v-1H5zm17.5 0H19v-1h3.5zM11.5 5V1.5h1V5zm0 17.5V19h1v3.5zM6.746 7.404l-2.16-2.098l.695-.745l2.111 2.135zM18.72 19.439l-2.117-2.141l.652-.702l2.16 2.098zM16.596 6.745l2.098-2.16l.745.695l-2.135 2.111zM4.562 18.72l2.14-2.117l.664.652l-2.08 2.179z"/>'
const DARK_ICON_PATH   = '<path fill="#fff700" d="M12.058 20q-3.333 0-5.667-2.334T4.058 12q0-2.47 1.413-4.535q1.414-2.067 4.01-2.973q.306-.107.536-.056t.381.199t.192.38q.04.233-.063.489q-.194.477-.282.971T10.158 7.5q0 2.673 1.863 4.537q1.864 1.863 4.537 1.863q.698 0 1.277-.148q.58-.148.988-.24q.218-.04.399.01t.292.176q.115.125.156.308t-.047.417q-.715 2.45-2.803 4.013T12.058 20"/>'


// --- Variables globales pour le cercle ---
window.circleCenter = null;        // [lng, lat]
window.circleRadiusKm = 50;
window.circleGeoJson = null;       // GeoJSON du cercle
window.editMode = false;           // État édition
window.circleVisible = false;      // État affichage cercle

function updateStlyeSwitchMode(){
  const themeButton = document.getElementById('themeButton');
  const themeIcon = document.getElementById('themeIcon');
  themeIcon.innerHTML = currentStyle === 'dark' ? DARK_ICON_PATH : LIGHT_ICON_PATH;
  themeButton.style.setProperty('background-color', currentStyle === 'dark' ? '#3E5DB5' : '#3BB1CE', 'important')
  const COLOR = currentStyle === 'dark' ? '#fff700' : '#FFD68A'
  themeIcon.querySelector('path').setAttribute('fill', COLOR);


}

updateStlyeSwitchMode()
// --- Scale mode ---
const SCALE_MODE = {
  linear: { functionSpace: count => count>0?count:0, linearizeSpace: y => Math.round(y) },
  log: { functionSpace: count => count>0?Math.log(count+1):0, linearizeSpace: y => Math.round(Math.exp(y)-1) }
};

// --- Update color title ---

let textColor = '#4676fccc'; // couleur par défaut pour dark mode

function updateTextColorForStyle(style) {
  if (style === 'dark') {
    textColor = '#4676fccc'; // texte clair sur fond sombre
  } else {
    textColor = '#210233cc'; // texte sombre sur fond clair
  }
  const titleEl = document.getElementById('pageTitle');
  if (titleEl) titleEl.style.color = textColor;
}

// --- Palette interpolation ---
function interpolatePalette(palette, n) {
  if(n<=0) return [];
  if(palette.length===1) return Array(n).fill(palette[0]);
  const result = [];
  const segments = palette.length-1;
  for(let i=0;i<n;i++){
    const t=i/(n-1);
    const segment=Math.min(Math.floor(t*segments), segments-1);
    const localT=(t-segment/segments)*segments;
    const c0=palette[segment], c1=palette[segment+1];
    result.push([
      Math.round(c0[0]+localT*(c1[0]-c0[0])),
      Math.round(c0[1]+localT*(c1[1]-c0[1])),
      Math.round(c0[2]+localT*(c1[2]-c0[2]))
    ]);
  }
  return result;
}

// --- Légende ---
function createLegend(interpolatedPalette, minValue, maxValue, scaleMode){
  const legendBar=document.getElementById('legendBar');
  legendBar.innerHTML='';
  interpolatedPalette.forEach(color=>{
    const div=document.createElement('div');
    div.style.background=`rgb(${color[0]},${color[1]},${color[2]})`;
    legendBar.appendChild(div);
  });
  const midValueColorSpace=(minValue+maxValue)/2;
  document.getElementById('minValue').textContent=SCALE_MODE[scaleMode].linearizeSpace(minValue);
  document.getElementById('midValue').textContent=SCALE_MODE[scaleMode].linearizeSpace(midValueColorSpace);
  document.getElementById('maxValue').textContent=SCALE_MODE[scaleMode].linearizeSpace(maxValue);
}

// --- Filtre compétences ---
const STACKS = ['Python','PHP','Java','JavaScript','TypeScript','React','Vue.js','Angular','C#','C++','Go','Rust','Ruby','Swift','Kotlin','SQL','NoSQL','Docker','Kubernetes','AWS','Azure','GCP','DevOps'];
const checkboxContainer = document.getElementById('filterCheckboxes');
STACKS.forEach(stack=>{
  const label = document.createElement('label');
  const cb = document.createElement('input');
  cb.type='checkbox';
  cb.value=stack;
  label.appendChild(cb);
  label.appendChild(document.createTextNode(' '+stack));
  checkboxContainer.appendChild(label);
});


// --- Drag middle mouse ---
function addMapDrag(map){
  let isMiddleDragging=false, startX=0, startY=0, startPitch=map.getPitch(), startBearing=map.getBearing();
  map.getCanvas().addEventListener('mousedown', e=>{
    if(e.button===1){ isMiddleDragging=true; startX=e.clientX; startY=e.clientY; startPitch=map.getPitch(); startBearing=map.getBearing(); e.preventDefault(); }
  });
  window.addEventListener('mouseup', e=>{ if(e.button===1) isMiddleDragging=false; });
  window.addEventListener('mousemove', e=>{
    if(!isMiddleDragging) return;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    map.setBearing(startBearing+dx*0.5);
    map.setPitch(Math.min(60, Math.max(0, startPitch-dy*0.3)));
  });
}

// Stats Calendar function 
const ID_DIV="statsCalendar"
const GAP_MONTH = 5; 
const D3_COLOR_INTERPOLATORS = [
  // --- Monochromes ---
  d3.interpolateBlues,
  d3.interpolateGreens,
  d3.interpolateGreys,
  d3.interpolateOranges,
  d3.interpolatePurples,
  d3.interpolateReds,

  // --- Nuances perceptuellement uniformes ---
  d3.interpolateViridis,
  d3.interpolateInferno,
  d3.interpolateMagma,
  d3.interpolatePlasma,
  d3.interpolateCividis,

  // --- Couleurs cycliques / arc-en-ciel ---
  d3.interpolateRainbow,
  d3.interpolateSinebow,

  // --- Divergentes ---
  d3.interpolateBrBG,
  d3.interpolatePRGn,
  d3.interpolatePiYG,
  d3.interpolatePuOr,
  d3.interpolateRdBu,
  d3.interpolateRdGy,
  d3.interpolateRdYlBu,
  d3.interpolateRdYlGn,
  d3.interpolateSpectral
];

const COLOR_INTERPOLATOR = d3.interpolateGreens;

function aggregateByDay(data) {
  const counts = d3.rollup(
    data,
    v => v.length,
    d => d3.utcDay(new Date(d.created))
  );
  console.table(Array.from(counts, ([date, value]) => ({ date, value })))
  return Array.from(counts, ([date, value]) => ({ date, value }));
}

function prepareData(aggData) {
  // Crée une Map avec clé = [année, mois, jour], valeur = count
  const dataMap = new Map(
    aggData.map(d => {
      const dt = d.date;
      const key = [dt.getUTCFullYear(), dt.getUTCMonth() + 1, dt.getUTCDate()].join('-'); // "YYYY-M-D"
      return [key, d.value];
    })
);

  const timeWeek = d3.utcMonday;
  const jours = ["Lun","Mar","Mer","Jeu","Ven","Sam","Dim"];
  const processed = [];

  const minDate = d3.min(aggData, d => d.date);
  const maxDate = d3.max(aggData, d => d.date);

  const startMonth = d3.utcMonth.floor(minDate);
  const endMonth = d3.utcMonth.ceil(maxDate);
  const months = d3.utcMonths(startMonth, endMonth);

  months.forEach(month => {
    const monthStart = d3.utcMonth.floor(month);
    const monthEnd = d3.utcMonth.offset(monthStart, 1);
    const days = d3.utcDays(monthStart, monthEnd);

      days.forEach(d => {
      const key = [d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate()].join('-');
      const count = dataMap.get(key) || 0;
      const n_day = (d.getUTCDay() + 6) % 7; // lundi = 0
      const n_week = timeWeek.count(monthStart, d); 
      const n_month = d.getUTCMonth() + 1; 
      const year = d.getUTCFullYear()
      const label_day = `${d.toLocaleDateString('fr-FR')}: ${count} offres`;
      processed.push({ date: d, count, n_day, n_week, n_month, year,label_day });
    });
  });
  return processed;
}

function drawLegend(svg, color, maxVal, cellSize, width, height) {
  const legendWidth = 200;
  const legendHeight = 12;
  const nTicks = 5;

  // Groupe de légende
  const legend = svg.append("g")
    .attr("class", "legend")
    .attr("transform", `translate(${width - legendWidth - 50}, ${height - 40})`);

  // Titre
  legend.append("text")
    .attr("x", legendWidth / 2)
    .attr("y", -5)
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-weight", "bold")
    .text("Nombre d'offres");

  // Dégradé
  const defs = svg.append("defs");
  const gradientId = "legend-gradient";

  const gradient = defs.append("linearGradient")
    .attr("id", gradientId)
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%");

  gradient.append("stop")
    .attr("offset", "0%")
    .attr("stop-color", color(0));

  gradient.append("stop")
    .attr("offset", "100%")
    .attr("stop-color", color(maxVal));

  // Rectangle de dégradé
  legend.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", legendWidth)
    .attr("height", legendHeight)
    .style("fill", `url(#${gradientId})`);

  // Échelle en nombre d’offres
  const legendScale = d3.scaleLinear()
    .domain([0, maxVal])
    .range([0, legendWidth]);

  // Génération explicite des ticks pour inclure 0 et maxVal
  const tickValues = Array.from({length: nTicks}, (_, i) => i * maxVal / (nTicks - 1));

  const legendAxis = d3.axisBottom(legendScale)
    .tickValues(tickValues)
    .tickFormat(d3.format("d"));

  legend.append("g")
    .attr("transform", `translate(0, ${legendHeight})`)
    .call(legendAxis);
}

function drawCalendar(data) {
  const aggData = aggregateByDay(data);
  const processed = prepareData(aggData);

  let gapRow = 40;//gap row => year
  let gapColumn = 15;//gap column => month
  const topPagging = 75

  const cellSize = 17;

  const weeksPerMonth = 5.5;
  const monthWidth = weeksPerMonth * cellSize +gapColumn

  const width = monthWidth*12+40;
  const height_row = cellSize * 7 +20
  // Groupe pas années
  const groupedByYear = d3.group(processed, d => d.year);



  const height = groupedByYear.size*height_row+gapRow*(groupedByYear.size-1) +topPagging -20;

  const maxVal = d3.max(processed, d => d.count) || 1;
  const color = d3.scaleSequential([0, maxVal], COLOR_INTERPOLATOR);

  d3.select(`#${ID_DIV}`).selectAll("*").remove();
  const svg = d3.select(`#${ID_DIV}`)
    .append("svg")
    .attr("width", width)
    .attr("height", height);


  const moisFR = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
  
  
  
  console.log("groupedByYear",groupedByYear,groupedByYear.size)
for (const [i, [year, yearDays]] of Array.from(groupedByYear.entries()).entries()) {
  console.log("Index:", i, "→ Année:", year, "→ Nombre de jours:", yearDays.length);
}
  for (const [i, [year, yearDays]] of Array.from(groupedByYear.entries()).entries()){
      const groupedByMonth = d3.group(yearDays, d => d.n_month);   

      let yOffset=(7*cellSize+gapRow)*(i)
    for (const [month, days] of groupedByMonth) {
      let xOffset = (month - 1) * monthWidth + 40;
      // Cases
      svg.append("g")
        .selectAll("rect")
        .data(days)
        .join("rect")
        .attr("class", "day-cell")
        .attr("width", cellSize - 1)
        .attr("height", cellSize - 1)
        .attr("x", d => xOffset + d.n_week * cellSize)
        .attr("y", d => d.n_day * cellSize + topPagging+yOffset)
        .attr("fill", d => color(d.count))
        .append("title")
        .text(d => d.label_day);

      // Label mois

      const lastX = xOffset + d3.max(days, d => d.n_week) * cellSize;
      svg.append("text")
        .attr("class", "month-label")
        .attr("x", (xOffset+ lastX + cellSize)/2)
        .attr("y", yOffset+topPagging-10)
        .attr("text-anchor", "middle")
        .text(moisFR[month - 1]);

      xOffset += (d3.max(days, d => d.n_week) + 1) * cellSize + GAP_MONTH;
    }

    // Jours
    const jours = ["Lun","Mar","Mer","Jeu","Ven","Sam","Dim"];
    svg.append("g")
      .selectAll("text")
      .data(jours)
      .join("text")
      .attr("class", "day-label")
      .attr("x", 35)
      .attr("y", (d,i) => i*cellSize + cellSize/1.5 + topPagging+yOffset)
      .text(d => d);

  const cx = 15;
  const cy =  (height_row/2 )+topPagging + i * (height_row+20)//yOffset + ((7 * cellSize) / 2)*(i+1);

  svg.append("g")
    .selectAll("text")
    .data([year])   // <- on transforme l'année en tableau à 1 élément
    .join("text")
    .attr("class", "year-label")
    .attr("x", cx)
    .attr("y", cy) // centrage vertical
    .attr("text-anchor", "middel") // centrer horizontalement si besoin
    .attr("transform", `rotate(-90, ${cx}, ${cy})`)
    .text(d => d);



  }
drawLegend(svg, COLOR_INTERPOLATOR, maxVal, cellSize, 280, 60);

}



// --- Init ---
async function main(){
  const brutData1 = await fetch('src/data/jobs_stacks.json').then(r=>r.json());
  const brutData2 = await fetch('src/data/offres.json').then(r=>r.json());
  const brutData = [...brutData1,...brutData2];

  const dates = brutData.map(d => new Date(d.created)).filter(d => !isNaN(d));
  const minDate = new Date(Math.min(...dates));
  const maxDate = new Date(Math.max(...dates));

  document.getElementById('minDate').valueAsDate = minDate;
  document.getElementById('maxDate').valueAsDate = maxDate;



  let data = applyFilter(brutData);

  const map = new maplibregl.Map({
    container:'map',
    style: MAP_STYLES[currentStyle].url,
    center:[2.3522,48.8566],
    zoom:9,
    pitch:50,
    bearing:-20,
    antialias:true
  });

  addMapDrag(map);

  let currentRadius=1000, currentElevation=50, currentCoverage=0.8,
      currentHexOpacity=0.8, currentBaseCoverage=1, currentBaseOpacity=0.5;

  function createHexLayer(){
    return new HexagonLayer({
      id:`hex-layer-${currentStyle}-${currentScaleMode}-${currentHexOpacity}`,
      data,
      getPosition:d=>[d.longitude,d.latitude],
      radius:currentRadius,
      elevationScale:currentElevation,
      extruded:true,
      coverage:currentCoverage,
      opacity:currentHexOpacity,
      pickable:true,
      getElevationValue: pts => SCALE_MODE[currentScaleMode].functionSpace(pts.length),
      colorAggregation:'MEAN',
      getColorValue: pts => SCALE_MODE[currentScaleMode].functionSpace(pts.length),
      colorRange: interpolatePalette(MAP_STYLES[currentStyle].colors, paletteColorLen),
      onSetColorDomain: domain => {
        const [minVal,maxVal]=domain;
        createLegend(interpolatePalette(MAP_STYLES[currentStyle].colors,paletteColorLen), minVal, maxVal, currentScaleMode);
      }
    });
  }

  function createHexBaseLayer(){
    return new HexagonLayer({
      id:`hex-base-layer-${currentStyle}-${currentScaleMode}-${currentBaseOpacity}`,
      data,
      getPosition:d=>[d.longitude,d.latitude],
      radius:currentRadius,
      extruded:false,
      coverage:currentBaseCoverage,
      opacity:currentBaseOpacity,
      colorAggregation:'MEAN',
      getColorValue: pts => SCALE_MODE[currentScaleMode].functionSpace(pts.length),
      colorRange: interpolatePalette(MAP_STYLES[currentStyle].colors, paletteColorLen),
      pickable:false,
      onSetColorDomain: domain => {
        const [minVal,maxVal]=domain;
        createLegend(interpolatePalette(MAP_STYLES[currentStyle].colors,paletteColorLen), minVal, maxVal, currentScaleMode);
      }
    });
  }

  let overlayLayers = [createHexBaseLayer(), createHexLayer()];
  const overlay = new MapboxOverlay({interleaved:true, layers:overlayLayers});
  map.addControl(overlay);
  function rebuildOverlayLayers() {
  data = applyFilter(brutData);
  overlayLayers = [];

  // Vérifie si le bouton a la classe 'active'
  if (document.getElementById('toggleBase').classList.contains('active')) {
    overlayLayers.push(createHexBaseLayer());
  }
  if (document.getElementById('toggleExtrude').classList.contains('active')) {
    overlayLayers.push(createHexLayer());
  }

  overlay.setProps({ layers: overlayLayers });
}

  // --- Bind sliders ---
  function bindSlider(sliderId, valueId, onChange){
    const s=document.getElementById(sliderId), v=document.getElementById(valueId);
    s.addEventListener('input', e=>{
      const val=e.target.value; v.textContent=val;
      onChange(val);
      rebuildOverlayLayers();
    });
  }

  bindSlider('radiusSlider','radiusValue',v=>{currentRadius=parseInt(v,10);});
  bindSlider('elevationSlider','elevationValue',v=>{currentElevation=parseInt(v,10);});
  bindSlider('coverageSlider','coverageValue',v=>{currentCoverage=parseFloat(v);});
  bindSlider('hexOpacitySlider','hexOpacityValue',v=>{currentHexOpacity=parseFloat(v);});
  bindSlider('baseCoverageSlider','baseCoverageValue',v=>{currentBaseCoverage=parseFloat(v);});
  bindSlider('baseOpacitySlider','baseOpacityValue',v=>{currentBaseOpacity=parseFloat(v);});


// --- Filtre fonction avec filtre géographique actif ---
function applyFilter(data){
  const selected = Array.from(document.querySelectorAll('#filterCheckboxes input:checked')).map(cb=>cb.value);
  const mode = document.getElementById('filterMode').value;
  const minDate = new Date(document.getElementById('minDate').value);
  const maxDate = new Date(document.getElementById('maxDate').value);

  // Récupère correctement les valeurs globales
  const circleActive = window.circleVisible;   // Bouton "active_circle"
  const center = window.circleCenter;
  const radiusKm = parseFloat(document.getElementById('cRadiusKm')?.value) || 0;

  // Crée le polygone une seule fois si nécessaire
  let circlePolygon = null;
  if(circleActive && center && radiusKm > 0){
    circlePolygon = turf.circle(center, radiusKm, {steps: 64, units: 'kilometers'});
  }

 const filtered =  data.filter(d=>{
    const stacks = Array.isArray(d.stacks) ? d.stacks : [];

    // --- Filtre stacks ---
    const stackOk = selected.length === 0 ? true :
                    mode==='OU' ? selected.some(tok=>stacks.includes(tok)) :
                                  selected.every(tok=>stacks.includes(tok));

    // --- Filtre dates ---
    const created = new Date(d.created);
    const dateOk = created >= minDate && created <= maxDate;

    // --- Filtre géographique ---
    let geoOk = true;
    if(circlePolygon && d.longitude != null && d.latitude != null){
      geoOk = turf.booleanPointInPolygon([d.longitude, d.latitude], circlePolygon);
    }

    return stackOk && dateOk && geoOk;
  });
  // --- Met à jour le calendrier ---
  drawCalendar(filtered);
  return filtered 
}

// --- Fonction pour dessiner / mettre à jour le cercle ---
function drawTurfCircle(center, radiusKm) {
  if (!center) return;

  // Crée un cercle Turf
  circleGeoJson = turf.circle(center, radiusKm, { steps: 64, units: 'kilometers' });

  if (map.getSource('circleSource')) {
    map.getSource('circleSource').setData(circleGeoJson);
    map.setLayoutProperty('circleLayer', 'visibility', circleVisible ? 'visible' : 'none');
  } else {
    map.addSource('circleSource', { type: 'geojson', data: circleGeoJson });
    map.addLayer({
      id: 'circleLayer',
      type: 'fill',
      source: 'circleSource',
      paint: {
        'fill-color': 'rgba(255,0,0,0.3)',
        'fill-outline-color': 'red'
      },
      layout: {
        visibility: circleVisible ? 'visible' : 'none'
      }
    });
  }
}

// --- Bouton Edit Circle ---
const editButton = document.getElementById('edit_circle');
editButton.textContent = 'Edit Circle';
editButton.addEventListener('click', () => {
  editMode = !editMode;
  if (!circleVisible){
   document.getElementById('active_circle').click();
  }
  editButton.style.backgroundColor = editMode ? '#3BB1CE' : '';
});

// --- Bouton Active Circle ---
const activeButton = document.getElementById('active_circle');
activeButton.textContent = 'Show Circle';
activeButton.addEventListener('click', () => {
  circleVisible = !circleVisible;
  activeButton.style.backgroundColor = circleVisible ? '#3BB1CE' : '';
  if (map.getLayer('circleLayer')) {
    map.setLayoutProperty('circleLayer', 'visibility', circleVisible ? 'visible' : 'none');
  }
  rebuildOverlayLayers()
  applyFilter(brutData);   // <-- ajoute ça
});

// --- Click sur la map pour définir le centre ---
map.on('click', (e) => {
  if (!editMode) return;
  circleCenter = [e.lngLat.lng, e.lngLat.lat];
  drawTurfCircle(circleCenter, circleRadiusKm);
   
  rebuildOverlayLayers();
  applyFilter(brutData);   // <-- ajoute ça
});

// --- Mise à jour du rayon ---
const radiusInput = document.getElementById('cRadiusKm');
radiusInput.addEventListener('input', e => {
  circleRadiusKm = parseFloat(e.target.value);
  drawTurfCircle(circleCenter, circleRadiusKm);

  rebuildOverlayLayers();
  applyFilter(brutData);   // <-- ajoute ça
});

  // --- Affichage Base / Extrude
const toggleBase = document.getElementById('toggleBase');
const toggleExtrude = document.getElementById('toggleExtrude');

[toggleBase, toggleExtrude].forEach(btn => {
  btn.addEventListener('click', () => {
    btn.classList.toggle('active'); // toggle état actif/inactif
     
    rebuildOverlayLayers();         // fonction existante pour la carte
  });
});

  
  document.getElementById('scaleMode').addEventListener('change', e=>{currentScaleMode=e.target.value; rebuildOverlayLayers();});
  document.getElementById('styleMode').addEventListener('change', e=>{currentStyle=e.target.value; map.setStyle(MAP_STYLES[currentStyle].url); rebuildOverlayLayers();updateTextColorForStyle(currentStyle);});
  document.getElementById('themeIcon').addEventListener('click', () => {
    currentStyle = currentStyle === 'dark' ? 'light' : 'dark';

    // Change l'icône
    // themeIcon.innerHTML = currentStyle === 'dark' ? DARK_ICON_PATH : LIGHT_ICON_PATH;
    updateStlyeSwitchMode()
    map.setStyle(MAP_STYLES[currentStyle].url);
    rebuildOverlayLayers();
    updateTextColorForStyle(currentStyle)
  });
  // Toggle contrôles
  document.getElementById('controlsHeader').addEventListener('click', ()=>{ 
    const content=document.getElementById('controlsContent');
    content.style.display = (content.style.display==='none')?'block':'none';
  });

  // Toggle filtre
  document.getElementById('filterHeader').addEventListener('click', ()=>{ 
    const content=document.getElementById('filterContent');
    content.style.display = (content.style.display==='none')?'block':'none';
  });

  // Rebuild overlay quand filtre change
  document.querySelectorAll('#filterCheckboxes input, #filterMode').forEach(el=>{
    el.addEventListener('change', rebuildOverlayLayers);
  });
  // Reduild filtre date range 
  document.getElementById('minDate').addEventListener('change', rebuildOverlayLayers);
  document.getElementById('maxDate').addEventListener('change', rebuildOverlayLayers);

}


main();
</script>
</body>
</html>
